pub struct AspectGeneratorMutableModifier ; impl MutableModuleModifier for AspectGeneratorMutableModifier { fn matches (item : & mut Item) -> bool { match item { Item :: Impl (item_impl) => { if item_impl . self_ty . to_token_stream () . to_string () == "One" . to_string () { let item_impl_idents = item_impl . items . iter () . flat_map (| i | match i { ImplItem :: Method (m) => vec ! [m . sig . ident . to_token_stream () . to_string () . clone ()] , _ => vec ! [] }) . collect :: < Vec < String >> () ; for i in item_impl_idents . iter () { if "one_two_three" . to_string () != i . clone () { return false ; } } return true ; } } _ => { } } false } fn do_provide (item : & mut Item) -> Option < TokenStream > { match item { Item :: Impl (item_impl) => { if item_impl . self_ty . to_token_stream () . to_string () == "One" . to_string () { return Some (quote ! { paste ! { pub trait [< "one_two_threeKXYAULRKFX " One >] { fn [< proceed "one_two_threeKXYAULRKFX " >] (& self , one : One) -> String ; } impl [< "one_two_threeKXYAULRKFX " One >] for One { fn [< proceed "one_two_threeKXYAULRKFX " >] (& self , one : One) -> String { { print ! ("testing...") ; print ! ("{} is one" , one . two . to_string ()) ; "two one" . to_string () } } } } impl One { pub fn one_two_three (& self , one : One) -> String { println ! ("hello") ; println ! ("{}" , self . two . clone ()) ; let found = self . proceedone_two_threeKXYAULRKFX (one) ; let mut three_four = "four three " . to_string () + found . as_str () ; three_four } } }) ; } } _ => { } } None } }